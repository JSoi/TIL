# 1부 - 하드웨어

컴퓨터의 논리와 구조



### **HDD와 SSD의 차이**

**주기억 장치**는 정보 저장 용량이 한정적, 휘발성을 지닌다

**보조 기억 장치**는 전원이 꺼져 있을 때도 작동 - ex: 하드 디스크, 하드 드라이브 , SSD (Solid State Drive)

**자기 디스크** : 회전하는 금속 표면에 있는 자성 물질의 미세한 영역이 자성을 띠는 방향을 설정하여 정보를 저장한다. (RAM보다 저렴)

**SSD**는 **플래시 메모리**(비휘발성)를 사용한다. 👉 전원이 꺼져 있어도 개별 소자에 전하를 유지하는 회로에 정보가 전하 형태로 저장된다.

**플래시 메모리** : 소모 전력에 제약이 있는 스마트폰에서 사용(대부분의 노트북에서 사용), 빠르고 안정적이고 비싸다!

**디스크 드라이브** : 컴퓨터의 논리적 구조와 물리적 구현 간의 차이가 나타나는 예

- 윈도우의 파일 탐색기 : 데이터는 장치에 저장*(물리적)*되지만, 드라이브(HW) + 파일 시스템(SW)의 합작으로 계층화된 구조*(논리적)*를 보여준다.

**추상화** : 논리적 구현의 세부 사항을 숨기는 것

**버스** : 전선 같은 개념으로 입출력, 통신 등 다양한 구성 요소를 연결함

	- USB(Universal Serial Bus) : 컴퓨터에 장치를 연결하기 위해 어디서나 사용됨
	- 프로세서 - 메모리 사이도 버스로 연결되어 있다.



### 가로세로 1cm 프로세서 칩

SD카드(Secure Digital card) :

논리 게이트 : 한 개나 두 개의 입력 값을 바탕으로 단일 출력 값을 만들어 낸다 👉 어떤 종류의 계산도 수행할 수 있다.

트랜지스터 : 스위치 역할(전류를 켜거나 끄는 장치)을 하며, 트랜지스터를 이용하여 복잡한 시스템을 구성할 수 있다.

집적회로(칩, 마이크로칩) 

- 논리 게이트가 만들어지는 곳
- 모든 소자와 배선이 단일 평면(얇은 실리콘 판) 위에 들어가 있다
- 원형 웨이퍼 상에서 한꺼번에 제조되어 조각내어지면 칩이 만들어진다



### 50년 넘게 유지된 무어의 법칙

일정한 크기의 집적회로에 들어갈 수 있는 트랜지스터의 수가 매년 대략 두 배가 된다

(트랜지스터의 수는 컴퓨팅 성능을 나타내는 지표)



### 연속과 불연속

컴퓨터가 정보를 표현하는 방식

1. 컴퓨터는 디지털 처리 장치다 - 디지털 정보를 받고, 처리하며 저장
2. 정보를 비트(0 or 1)로 표현한다
3. 비트는 모여서 더 큰 정보를 표현한다 ( 숫자부터 영화, 명령어까지! )



#### 아날로그와 디지털

**아날로그** : 연속적으로 변하는 값

- (시침, 분침 있는) 시계, (바늘 있는) 속도계, (수은) 온도계, 자동차 핸들

![analog](https://user-images.githubusercontent.com/17975647/169059226-f42d8dbc-6fd0-49a9-9d44-b844d89bc724.png)

**디지털** : 불연속적인 값

- 근사치로 표현한다 👉디지털 속도계의 경우 시속 66km / 시속 65km. 그 사이는 없다

![digital](https://user-images.githubusercontent.com/17975647/169058942-74da5547-ad77-4064-85e4-eedca2e0985c.png)

외부 세계의 데이터들은 거의 다 아날로그이다 (소리, 온도, 영상, 움직임 등)

#### 그런데도 디지털 방식을 사용하는 이유는 무엇일까?

가장 큰 이유는 디지털 데이터가 다루기 쉽기 때문이다

디지털 데이터는 불필요하거나 중요하지 않은 정보를 버리는 방식으로 *압축*될 수 있어 네트워크로 전송시 효과적이다.

뿐만 아니라 확장, 병합, 복사, 전송, 저장에도 용이하다





### 아날로그 정보를 디지털로 바꾸기

#### 1. 이미지 디지털화하기

아날로그 카메라 : 감광 영역을 빛에 노출하여 영상을 만들어 낸다

디지털 카메라 : 

- 광검출 소자에 들어오는 빛의 양에 비례하는 양으로 전하를 저장한다.

- 전하가 수치로 변환된다.  광검출 소자의 수가 많아지게 되면 원형을 더 정확하게 담아내게 된다

- 센서 배열의 각 요소는 RGB 빛의 양을 측정하는 세 개의 검출 소자로 구성된다. 각 요소를 '픽셀-화소'이라 한다.



#### 2. 음향 디지털화하기

**소리**란 : 음원에서 발생한 진동이 공기에 압력 변화 👉 파동으로 전환되어 고막을 진동 👉신경활동으로 전환

**축음기** : 기압 변동을 밀랍 기둥의 홈으로 변환(녹음), 이 패턴을 기압 변동으로 변환(재생)

**디지털 표현** : 아날로그 신호를 일정 시간 간격으로 측정하고, 이를 모아둔 것 (더 자주 측정할수록 곡선의 값에 가까운 수치가 된다)



#### 3. 영화 디지털화하기

일련의 정지 영상을 빠르게 연속해서 보여 준다!

영화는 영상 요소와 음향을 결합하고 동기화해야 하기 때문에 압축 기술(ex : MPEG)을 사용해 용량을 줄인다



#### 4. 텍스트 디지털화하기

글자, 숫자, 구두점 같은 일반 텍스트는 숫자를 부여해 변환할 수 있다.

> #### ASCII
>
> A : 65 - Z : 90
>
> a : 97 - z : 122
>
> 0 : 48 - 0 : 57

> #### Unicode
> 모든 문자에 고유한 숫자 값을 지정한다(심지어 중국어까지!)



어디서 들어본 듯한 디지털화

### 디지털화 = 표본화 + 양자화 + 부호화

![sampling](https://user-images.githubusercontent.com/17975647/169066070-dbe6228f-d44a-48f9-985f-c5d6eaaa8e24.png)

#### 1) 표본화(Sampling)

아날로그 파형을 디지털 형태로 변환하기 위해 표본을 취하는 것을 의미한다.


#### 2) 양자화(Quantizing)

표본화된 각 점을 어느 정도의 정밀도로 표현할 것인지 정하는 것을 의미한다. 

- 구간별(y축)로 구분하고, 각 구간의 대푯값으로 치환


#### 3) 부호화(Coding)

표본화와 양자화를 거친 디지털 정보를 2진수로 표현화는 과정이다.

각 구간별로 이진 부호를 할당하고 각 샘플을 이진 부호로 변환

![image](https://user-images.githubusercontent.com/17975647/169066532-148a8e9e-92ee-4e95-a552-52307a4ac78e.png)



### 0과 1의 세계

#### 디지털 시스템
모든 유형의 정보를 숫자 값(이진수)으로 표현함

#### 비트
이진 숫자를 의미한다

이진 숫자로 더 복잡한 정보를 표현할 방법이 필요하다
👉 **조합에 의미를 할당하자**

이진 숫자 N개로 표현 할 수 있는 비트 패턴의 개수는 2^N
십진 숫자 N개로 표현할 수 있는 배턴의 개수는 10^N개가 된다



### 비트 모아 데이터

#### 이진수

0과 1로 데이터를 표현한다.

수에서 2의 거듭제곱을 하나씩 내려가면서 뺌으로써 십진수를 이진수로 변환한다.



#### 바이트

단일 바이트로는 256개의 구별되는 값(0-255)을 인코딩할 수 있다. 

하지만 유니코드 한 개는 2바이트이며, 이는 이진수로 표기하기에 길다

그래서 16진수를 사용하게 된다.



### 프로세서와 계산기의 다른 점

프로세서에는 수행할 수 있는 기본 연산들의 레퍼토리가 있다.

컴퓨터 나머지 부분을 제어한다. 버스로 전송되는 신호르 롱해 마우스 ,키보드, 디스플레이 기타 전기적으로 연결된 모든 장치에 대한 입력과 출력을 조작하고 조정한다.



### 모형 컴퓨터로 더하기 프로그램 만들기

모형 컴퓨터를 통해 프로그램이 어떻게 실행되는 지 보자!

모형 컴퓨터의 명령어

**GET** : 키보드에 수를 입력받은 후 누산기에 넣는다(누산기 내용 덮어 쓰기)

**PRINT** : 누산기 내용을 출력한다

**STORE M** : 누산기 내용의 복사본을 메모리 위치 M에 저장한다

**LOAD M** : 메모리 위치 M의 내용을 누산기에 적재한다

**ADD M** : 메모리 위치 M의 내용을 누산기에 더한다.

STOP : 실행 멈춤

**누산기** : 한 개의 수를 담을 만한 용량의 부가적인 저장 영역

메모리에 값을 저장한 후 그 값을 가져오자

**분기 명령** : store, add, get 명령을 한 번 더 추가하자 / 조건부 분기(점프) - IFZERO

#### **메모리 내부 표현**

명령어는 하나의 메모리에 들어가며, 다음 메모리 위치를 참조하면 두 칸의 메모리가 들어간다.

프로세서는 인출, 해석, 실행 등 일련의 과정을 반복한다.





### 프로세서는 무조건 빠른게 좋을까?

프로세서는 인출, 해석, 실행 사이클을 반복 수행한다

#### 인출

다음에 처리할 명령어를 인출한다

#### 해석

명령어가 무슨일을 하는지 파악하고 명령어를 수행하는 데 필요한 모든 준비를 마친다

#### 실행

메모리에서 정보를 가져 오고, 산술 연산이나 논리 연산을 수행하며, 그 결과를 저장하는 일련의 작업을 명령어에 따라 적절하게 조합함



기본 명령어의 유형은 대부분 산술 연산, 비교/분기, 컴퓨터의 나머지 부분을 제어하는 것이다.

명령어와 데이터는 여러 개의 메모리 위치를 차지한다. 프로세서에는 누산기가 여러 개 있어서, 초고속 메모리 역할을 하는 누산기에 중간 결과를 하나 이상 담을 수 있다.

**컴퓨터 아키텍처**는 프로세서 설계와 더불어 프로세서와 컴퓨터 나머지 부분 간의 연결 방식 설계를 다루는 분야이다.

**명령어 집합** : 프로세서가 제공하는 명령어 레퍼토리를 뜻함



프로세서 속도는 매우 빨라서 명령어 한개를 짧은 시간 내에 수행한다. 반면에 메모리는 프로세서에 비해서는 느린 편이다.

그래서 프로세서와 메모리 사이에 있는 캐시를 사용한다.



#### 캐시

고속 메모리

프로세서와 메모리 사이에서 최근 사용된 명령어와 데이터를 담고 있다. 메모리에서 정보가 오기를 기다리기보다 캐시에서 찾을 수 있는 정보에 접근 하는 것이 속도면에서 더 낫다

인출과 실행 단계가 겹치도록 프로세서를 설계해서 명령어 여러 개가 다양한 단계에 걸쳐 진행되도록 만들 수 있다 

👉 이것이 **파이프라이닝**

파.이.프.라.이.닝..!

동시에 처리 가능한 일들을 동시에 처리함으로써 **처리량** 을 올리는 것이 파이프라이닝의 핵심이다.

이 경우 중요한 점은 각 단계를 수행하는 속도가 빨라지지는 않는다. 모든 단계는 원래의 동작속도대로 일을 해 나가지만 **병렬적으로 처리**를 함으로써 쉬는 시간을 없애어 전체 **처리량** 을 올려 많은 작업을 빠른 시간 내에 처리 할 수 있도록 하는 것이다.

![pipeline](https://user-images.githubusercontent.com/17975647/170038784-7620c942-010c-4719-a8ef-6b657b8ae634.png)



해저드 : 특정한 이유로 다음 clock cycle에 다음 명령어가 실행되지 않는 상황

**구조적 해저드**

- 자원은 하나인데 여러 명령이 동시에 수행되려고 할 때 발생

**데이터 해저드**

- 아직 pipeline 명령어가 끝나지 않은 register에 접근하여 명령어를 실행하려고 할 때

**제어 해저드**

- 분기 명령어를 통해 명령어를 건너뛰어버리면 PC 값이 변해버리고, 중간에 있는 명령어를 실행하지 않음

[참고: https://jesus-never-fail.tistory.com/13]



프로세서 여러개가 동시에 작업하도록 하는 기법도 있다 - 오늘날 휴대폰과 노트북에서 표준으로 사용되는 기능

단일 칩에 더 많은 프로세서 코어를 담거나, 컴퓨터마다 두 개 이상의 칩을 넣는 경향이 크다.



휴대폰과 태플릿 PC는 대부분 **ARM**이라는 프로세서 설계를 사용한다.

ARM 프로세서 설계는 전력을 적게 사용하도록 특별히 설계 된 방식이다. - 임베디드 시스템에서 많이 사용된다고 함



**그래서 무슨 프로세서가 빠를까?**😁

비교가 어렵다. 프로세서가 전력 소비를 낮추고자 빠른 실행 속도를 포기하기도 하고, 속도를 동적으로 조정하기도 한다.

정리하자면 요구사항에 따라 차이가 있는 것이다.



### 캐시가 뭔가요?

#### 캐시
용량이 크지만 느린 주 기억장치에 매번 접근하는 것을 피하고자 최근에 사용된 정보를 저장하는 데 사용한다.

캐싱이 효과적인 이유는 최근에 사용된 정보가 곧 다시 사용될 가능성이 크기 때문이다. - 메모리 작업을 기다리는 데 시간을 덜 쓴다.

캐싱은 포괄적인 의미에서 우리가 뭔가를 사용하며 그것을 곧 다시 쓸 가능성이 있거나 근처에 있는 뭔가를 사용할 가능성이 있을 때 활용하는 것이다

- 주 기억 장치는 디스크를 보완하는 캐시
- 메모리와 디스크는 네트워크에서 오는 데이터를 빠르게 꺼낼 수 있는 캐시이다

#### 웹 캐시

브라우저는 어떤 웹페이지에 포함된 이미지나 용량이 큰 다른 데이터의 로컬 사본을 유지하고 있다. 사용자가 페이지를 재방문했을 때 데이터를 다시 다운로드하기보다 로컬 사본을 사용하는 편이 더 빠르기 때문이다. 
 - 캐시가 커지면 오래된 항목부터 조용히 제거 / 사용자가 전체를 제거하는 것도 가능하다.

