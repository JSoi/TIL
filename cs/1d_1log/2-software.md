### 10억개 전화번호에서 이름 찾기 : 이진 검색

선형 알고리즘보다 더 나은 방법을 찾아보자.

전화번호부를 예시로 들어 보자 - 이름이 중간 페이지 이름보다 앞에 있으면 뒤쪽 절반은 무시하고 앞쪽 절반의 중간을 펼쳐 본다. 이렇게 반을 나누어 검색하는 것을 이진 탐색이라고 하며 분할 벙복이라는 일반적인 전략의 한 가지 예이다. 

이진 탐색에서 중요한 점은 수행해야 하는 일의 양이 데이터의 양이 증가하는 것에 비해 천천히 증가한다는 것이다. 알파벳순으로 정렬된 이름 1000개가 있을 때, 특정 이름을 찾으려면 이름 10개를 확인해야 한다. 이름이 2000개 있다면 이름 11개만 확인하면 된다. 마찬가지로 데이터의 양이 1000배가 되어도 10번의 단계만 더 필요해진다.



### 검색을 쉽게 만드는 정렬 : 선택 정렬 vs 퀵 정렬

**정렬** : 항목을 순서대로 배열해서 검색이 빨리 실행될 수 있도록 해준다.

#### 선택 정렬

남아있는 항목들 전체를 반복하여 검색하면서 매번 알파벳순으로 다음에 오는 이름을 찾는다. 

이름을 훑어보는 횟수는 원래 항목의 수에 정비례한다.

#### 퀵 정렬

항목을 훑어보면서 기준을 세워 그룹별로 모은다. 그러나 그룹의 크기가 비슷해야 좋은 효율을 낼 수 있다.

NlogN의 시간 복잡도를 갖는다.



### 10개 도시를 최단거리로 여행하는법

효율이 높은 알고리즘 : logN

퀵 정렬 : NlogN

지수 복잡도 : 2^N - 모든 경우를 한 번씩 시도해 봐야만 하는 상황에서 발생한다.

NP문제(비결정형 다항) : 실제로 발생하는 많은 문제나 그런 문제들의 근본이 되는 문제를 해결하려면 지수 알고리즘이 필요하다.

NP문제의 예시 : 여행하는 외판원 문제

다른 도시를 모두 방문하고 나서 다시 출발점으로 돌아와야 한다. 그 최소 거리를 구하자





### 알고리즘은 이상, 프로그래밍은 현실



> #### **알고리즘**
>
> 추상적이고, 이상적인 **절차**를 기술한 것으로, 구현에 필요한 세부 사항과 현실적인 고려 사항을 무시한다. 알고리즘은 결국 멈춰야 한다.



> #### 프로그램
>
> 추상적인 것과 거리가 멀다.
>
> 실제 컴퓨터가 과제를 완료하기 위해 수행해야 하는 모든 **단계를 구체적으로 서술**한다. 알고리즘과 달리 실질적인 문제도 신경써야 한다.
>
> 어떤 문제를 해결하기 위하여 그 처리 방법과 순서를 기술하여 컴퓨터에 주어지는 일련의 명령문 집합체를 뜻한다. 
>
> 사용자의 입력에 따라 그 입력된 값을 일정한 처리 방법과 순서에 따라 처리하여 결과를 산출해내는 **명령문 집합**이다.



알고리즘이 *청사진*이라면, 프로그램은 *건물* 같은 것이다.



#### 프로그래밍에서 일어나는 일

프로그래밍 언어 : 컴퓨터가 어떤 과제를 수행하는 데 필요한 계산 단계를 어느 정도 사람에게 자연스럽게 표현해주는 것

컴퓨터 자원을 관리하는 일 : 컴퓨터가 자신의 동작을 직접 제어하도록 하며, 이는 **운영체제**로 이어진다.





### 다른 프로그램을 처리하기 위한 프로그램



**어셈블러** : 특정한 처리를 수행하는 프로그램 - 

기본 컴퓨터 명령어들을, 컴퓨터 프로세서가 기본 연산을 수행하는데 사용할 수 있는 비트 패턴으로 변환시키는 프로그램이다.



**어셈블리 언어**(어셈블리어): 어셈블러를 작성하는데 사용되는 언어

어셈블리어는 기계어와 1:1대응이 되는 컴퓨터 프로그래밍 저급 언어이다. 기계어는 사람 기준으로 컴퓨터가 바로 읽을 수 있다는 점을 제외하고는 장점이 없는 언어이기 때문에 어셈블리가 탄생했다. 이런 저급 언어는 배우기 어렵고 유지보수가 어렵다는 이유 때문에 잘 사용되지는 않는다. (임베디드, 보안 분야는.. 알아야 함)

어셈블리 언어는 대개 프로세서의 명령어와 일대일로 연결되고, 명령어가 이진수로 인코딩되는 특정한 방식과 메모리에 정보가 배치되는 방식 등을 알고 있다. 즉, 어떤 작업을 수행하기 위해 특정 종류의 프로세서의 어셈블리 언어로 작성된 프로그램은 다른 프로세서에 맞춰 작성된 어셈블리 언어 프로그램과는 다르다는 뜻이다. 특정 프로세서용 어셈블리 언어 프로그램을 다른 프로세서용으로 변환하고 싶다면 프로그램을 완전히 새로 작성해야 한다.



####  Intel 문법과 AT&T 문법 

어셈블리어에는 Intel문법과 AT&T 문법이 존재하며 또한 이들은 서로 호환되지 않는다. 문법에 대해 차이점이 존재하기 떄문이다.

![assemblyop](https://user-images.githubusercontent.com/17975647/171069865-80fca289-0516-4dfc-8c0b-cb474a26a080.png)

Intel Operand의 경우 Operand2가 Source고 Operand1이 Destination이 되며 EBX의 값을 EAX에 더한다라는 뜻이 된다

반면에 AT&T의 경우에는 반대가 되어 EAX의 값을 EBX로 더한다



<**숫자 표기 방식**>

Intel (숫자를 그대로 사용)

ex) 1, 2, 3, 4, 5 

 

AT&T (앞에 $를 붙여서 사용)

ex) $1, $2, $3, $4, $5



<**레지스터 표기 방식**>

Intel (명칭 그대로 사용)

ex) EAX, EBX, EBP

 

AT&T (앞에 %를 붙임)

ex) %EAX, %EBX, %EBP



### 구글 같은 서비스는 어떻게 개발할까?

무엇을 해야 할 지 파악하고, 넓은 명세부터 시작해서 작은 부분으로 나누고, 각 부분을 작업하면서 전체적으로 일관되어 있는지 확인해야 한다.

다른 프로그래머들이 작성한 부분이 *함께 작동*하는지 확인해야 한다 -> 이 부분에서 에러가 날 확률이 높다

ex) 2015년 구글의 전체 코드 규모 : 20억행 -> 이 정도 규모의 소프트웨어를 개발하려면 프로그래머, 테스트 담당자, 문서 작성자로 이루어진 팀이 필요하다.



#### 라이브러리 = 연관된 함수들의 모음

당장 집을 짓는다고 생각해보자. 나무를 베어서 통나무를 만들고, 찰흙으로 벽돌을 만들지는 않을 것이다. 

다른 이들이 만들어 놓은 것을 가져다 쓸 가능성이 높다.

프로그래밍도 마찬가지이다. 이미 존재하는 구성 요소(운영체제 포함)를 이해하고 자신만의 방식으로 이어 붙여아 한다.

프로그래밍 언어는 함수 메커니즘을 제공한다.



#### 함수 매커니즘

어떤 프로그래머가 유용한 작업을 수행하는 코드를 작성하면 다른 프로그래머가 내부 작동 방식을 모르더라도 코드를 패키지화할 수 있게 해주는 것

```
모형 컴퓨터의 GET 👉 C언어의 scanf
모형 컴퓨터의 PRINT 👉 C언어의 printf
```

-> 따로 만들어진 구성 요소를 조합해서 프로그램을 만든다.



#### 애플리케이션 프로그래밍 인터페이스(API)

함수 라이브러리가 제공하는 서비스이다

용도, 요구하는 데이터, 출력값을 나열한다.

- 시스템을 효과적으로 사용하도록 돕는 지원 문서도 포함한다.



#### 소프트웨어 개발 키트 (SDK)

대규모 시스템에서 프로그래머들이 복잡한 소프트웨어 라이브러리를 잘 다룰 수 있도록 작성한 것



#### 버그 :bug:

프로그램이 일정 규모 이상 커지면 한 번에 작동하지 않는다😢

사실 규모가 크든 작든 버그는 있기 마련이다..

버그의 원인

- 발생할 수 있는 경우를 깜빡하고 처리하지 못했다 

- 테스트를 잘못 작성했다

- 잘못된 공식을 사용한다

- 할당된 메모리의 바깥에 접근했다

버그가 생기면?

시스템을 공격에 취약하게 만들기도 한다

- 공격자가 메모리에 악성코드를 심어 놓기 쉬워진다.



#### 테스트

더 많은 버그를 미리, 최대한 많이 잡아내기 위해서 테스트를 실행한다.

``` return 
return 5/9 * f-32 👉 return 5/9 * (f-32)
```

이미 알고 있는 값을 넣어보면서 원하는 값이 나오는지 대조해본다

오히려 구현코드보다 테스트 코드가의 양이 더 많다.



#### 급변하는 환경에 맞춰서 대응하자

개발에 복잡함을 더하는 요인이다. 환경이 변하고, 프로그램이 대응해야 한다.

ex1) 미국의 납세 신고 처리 소프트웨어는 세법이 바뀔 때마다 대응

ex2 ) 1990년대 초의 워드는 최신 워드에서 열리지 않는다.

소프트웨어 유지보수에서 매우 중요하다.

변화에 대응하지 못하면 비트 부식을 겪게 된다. (재컴파일 불가, 라이브러리 작동X, 업데이트 불가)



### 기술 표준의 중요성

표준 : 기술적 산물이 어떻게 만들어지고 작동하도록 되어 있는지 명확하고 상세하게 기술된 것

보통 준중립적인 단체에 의해 개발되고 유지된다. ex) 플러그 규격, 전압에 대한 표준

소프트웨어 표준 : 아스키코드와 유니코드

표준은 상호운용성 보장, 공개경쟁이 이루어지도록 하는데 결정적이다.



### 자유로운 소프트웨어, 오픈소스

소스 코드 : 프로그래머가 작성하는 코드

오브젝트 코드 : 소스 코드를 프로세서에서 컴파일한 결과

👉 상용 소프트웨어는 소스 코드는 오브젝트 코드 형태로만 배포된다.

#### 오픈 소스

연구와 개선 활동을 위해 다른 사람들도 소스 코드를 자유롭게 사용할 수 있도록 하는 대안

*오픈 소스의 예 )* Go, Swift,Rust, C#, F#, Linux

오픈소스로 수익을 얻기 위해서는 기술 지원, 교육, 품질 보증, 시스템 통합과 서비스 이용에 요금을 청구함으로써 수익을 얻는다.



**JPL** : 라이선스가 적용된 소프트웨어를 자유롭게 사용할 수 있다고 명시한다.

소프트웨어가 배포되면,  그 배포판도 소스코드를 사용할 수 있어야 한다.



### 컴퓨터를 작동하게 만드는 운영체제

#### 운영체제

컴퓨터 하드웨어를 관리하고 다른 프로그램을 실행할 수 있게 하는 소프트웨어의 기초 구조물

1. 운영체제는 컴퓨터의 자원을 제어하고 할당한다.

- 프로세서를 관리하면서 현재 사용 중인 프로그램을 스케줄링하고 프로그램 간의 관계를 조정한다.
- 특정 시점에 활발히 연산하는 프로그램 간의 에 프로세서의 초점을 전환해 준다.

2. 주기억 장치를 관리한다. 메모리에 프로그램을 로드해서 프로그램이 명령어 실행을 시작할 수 있게 해준다.

- 메모리에 프로그램을 로드해서 명려엉 실행 시작을 가능하게 한다.
- 메모리 용량이 충분치 않으면 프로그램을 일시적으로 디스크로 복사했다가, 다시 메모리에 공간이 생기면 도로 옮겨 준다.
  - 메모리 사용을 위해서는 적절한 공학적 기법이 필요함👉스와핑
  - 스와핑이란? 프로그램의 일부만 메모리ㅇ 가져오고 비활성화 상태일 때 꺼내서 디스크에 복사함.

3. 보조 기억 장치에 저장된 정보를 관리한다(파일 시스템)

- 우리에게 익숙한 계층형 파일 구조를 보여준다.

4. 컴퓨터에 연결된 장치들의 활동을 관리하고 조정한다.

#### 애플리케이션

운영체제 위에서 실행되는 프로그램 ex) 브라우저, 워드프로세서..

