### 10억개 전화번호에서 이름 찾기 : 이진 검색

선형 알고리즘보다 더 나은 방법을 찾아보자.

전화번호부를 예시로 들어 보자 - 이름이 중간 페이지 이름보다 앞에 있으면 뒤쪽 절반은 무시하고 앞쪽 절반의 중간을 펼쳐 본다. 이렇게 반을 나누어 검색하는 것을 이진 탐색이라고 하며 분할 벙복이라는 일반적인 전략의 한 가지 예이다. 

이진 탐색에서 중요한 점은 수행해야 하는 일의 양이 데이터의 양이 증가하는 것에 비해 천천히 증가한다는 것이다. 알파벳순으로 정렬된 이름 1000개가 있을 때, 특정 이름을 찾으려면 이름 10개를 확인해야 한다. 이름이 2000개 있다면 이름 11개만 확인하면 된다. 마찬가지로 데이터의 양이 1000배가 되어도 10번의 단계만 더 필요해진다.



### 검색을 쉽게 만드는 정렬 : 선택 정렬 vs 퀵 정렬

**정렬** : 항목을 순서대로 배열해서 검색이 빨리 실행될 수 있도록 해준다.

#### 선택 정렬

남아있는 항목들 전체를 반복하여 검색하면서 매번 알파벳순으로 다음에 오는 이름을 찾는다. 

이름을 훑어보는 횟수는 원래 항목의 수에 정비례한다.

#### 퀵 정렬

항목을 훑어보면서 기준을 세워 그룹별로 모은다. 그러나 그룹의 크기가 비슷해야 좋은 효율을 낼 수 있다.

NlogN의 시간 복잡도를 갖는다.





### 알고리즘은 이상, 프로그래밍은 현실



> #### **알고리즘**
>
> 추상적이고, 이상적인 **절차**를 기술한 것으로, 구현에 필요한 세부 사항과 현실적인 고려 사항을 무시한다. 알고리즘은 결국 멈춰야 한다.



> #### 프로그램
>
> 추상적인 것과 거리가 멀다.
>
> 실제 컴퓨터가 과제를 완료하기 위해 수행해야 하는 모든 **단계를 구체적으로 서술**한다. 알고리즘과 달리 실질적인 문제도 신경써야 한다.
>
> 어떤 문제를 해결하기 위하여 그 처리 방법과 순서를 기술하여 컴퓨터에 주어지는 일련의 명령문 집합체를 뜻한다. 
>
> 사용자의 입력에 따라 그 입력된 값을 일정한 처리 방법과 순서에 따라 처리하여 결과를 산출해내는 **명령문 집합**이다.



알고리즘이 *청사진*이라면, 프로그램은 *건물* 같은 것이다.



#### 프로그래밍에서 일어나는 일

프로그래밍 언어 : 컴퓨터가 어떤 과제를 수행하는 데 필요한 계산 단계를 어느 정도 사람에게 자연스럽게 표현해주는 것

컴퓨터 자원을 관리하는 일 : 컴퓨터가 자신의 동작을 직접 제어하도록 하며, 이는 **운영체제**로 이어진다.



### 다른 프로그램을 처리하기 위한 프로그램



**어셈블러** : 특정한 처리를 수행하는 프로그램 - 

기본 컴퓨터 명령어들을, 컴퓨터 프로세서가 기본 연산을 수행하는데 사용할 수 있는 비트 패턴으로 변환시키는 프로그램이다.



**어셈블리 언어**(어셈블리어): 어셈블러를 작성하는데 사용되는 언어

어셈블리어는 기계어와 1:1대응이 되는 컴퓨터 프로그래밍 저급 언어이다. 기계어는 사람 기준으로 컴퓨터가 바로 읽을 수 있다는 점을 제외하고는 장점이 없는 언어이기 때문에 어셈블리가 탄생했다. 이런 저급 언어는 배우기 어렵고 유지보수가 어렵다는 이유 때문에 잘 사용되지는 않는다. (임베디드, 보안 분야는.. 알아야 함)

어셈블리 언어는 대개 프로세서의 명령어와 일대일로 연결되고, 명령어가 이진수로 인코딩되는 특정한 방식과 메모리에 정보가 배치되는 방식 등을 알고 있다. 즉, 어떤 작업을 수행하기 위해 특정 종류의 프로세서의 어셈블리 언어로 작성된 프로그램은 다른 프로세서에 맞춰 작성된 어셈블리 언어 프로그램과는 다르다는 뜻이다. 특정 프로세서용 어셈블리 언어 프로그램을 다른 프로세서용으로 변환하고 싶다면 프로그램을 완전히 새로 작성해야 한다.



####  Intel 문법과 AT&T 문법 

어셈블리어에는 Intel문법과 AT&T 문법이 존재하며 또한 이들은 서로 호환되지 않는다. 문법에 대해 차이점이 존재하기 떄문이다.

![assemblyop](https://user-images.githubusercontent.com/17975647/171069865-80fca289-0516-4dfc-8c0b-cb474a26a080.png)

Intel Operand의 경우 Operand2가 Source고 Operand1이 Destination이 되며 EBX의 값을 EAX에 더한다라는 뜻이 된다

반면에 AT&T의 경우에는 반대가 되어 EAX의 값을 EBX로 더한다



<**숫자 표기 방식**>

Intel (숫자를 그대로 사용)

ex) 1, 2, 3, 4, 5 

 

AT&T (앞에 $를 붙여서 사용)

ex) $1, $2, $3, $4, $5



<**레지스터 표기 방식**>

Intel (명칭 그대로 사용)

ex) EAX, EBX, EBP

 

AT&T (앞에 %를 붙임)

ex) %EAX, %EBX, %EBP
