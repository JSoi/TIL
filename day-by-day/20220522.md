# 20220522 TIL&WIL

Python에 익숙해지면서, Python으로 알고리즘을 구현해보고, 문제를 풀어보는 주였다

한 주에 걸쳐서 배운 알고리즘을 간단하게 정리해보려 한다 😃



## 배열 & 리스트

파이썬의 리스트는 우리가 아는 배열과 같이 구현되어 있다고 한다. ^^;

하지만 파이썬의 리스트는 고정적인 크기(배열의 대표적 특성)를 갖지 않는다.

그래서인지 push, pop이 반복되는 Stack 같은 다른 자료구조들도 리스트를 많이 활용하는 듯하다.

여지껏 문제를 풀어오면서 스택, 리스트, 배열 등은 파이썬 리스트 하나로 구현했다

------

굳이 배열과 비슷한 자료구조를 찾자면 넘파이(numpy)이라 하는데, 아래에서 잠깐.. 짧게 설명하겠다

### numpy

파이썬은 자체적으로 배열 자료형을 제공하지 않는다. 따라서 배열을 구현한 다른 패키지를 임포트해야 한다. 파이썬에서 배열을 사용하기 위한 표준 패키지는 넘파이(NumPy)다.

#### 1차원 배열 만들기

```
array
```

넘파이의 `array` 함수에 리스트를 넣으면 `ndarray` 클래스 객체 즉, 배열로 변환해 준다. 따라서 1 차원 배열을 만드는 방법은 다음과 같다.

```
ar = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

-------

또한 파이썬에서 리스트가 굉장히 자주 쓰이는 것 같아 정리해 보겠다.

#### 파이썬 리스트 형식

```python
intList = [1, 2, 3, 4, 5]
strList = ["jsoi", "name", "jeong"]
```

#### 초기화, 선언

``` python
list1 = list() # []
list = [1,2,3,4,5]
```

#### 리스트와 연산자

``` python
list = [3] * 3 # [3,3,3]
list = [1,2,3]+[4,5,6] # [1,2,3,4,5,6]
```

#### 값 하나 읽어오기

```python
a = [0,1,2,3]
b = [0,1,2,[0,1]] # 이렇게 리스트 안에 리스트를 넣을 수도 있다!
a[index] # index번째의 값
a[-1] # 마지막 요소값
b[3] # 3번째 요소인 [0,1]
b[3,0] # [0,1] 중 첫 번째 원소인 0
```

#### Slicing

```python
a = [0,1,2,3,4,5]
b = a[0:2] # 0포함 ~ 2 직전까지 슬라이싱
c = a[2:] # 2번째 인덱스부터 마지막 인덱스까지 슬라이싱
```


#### 추가

```python
list.append(x)
# list의 마지막에 x 추가
```
![python-append](https://user-images.githubusercontent.com/17975647/169684689-4aef01cf-d916-4f94-b69d-385b98ecb9f6.png)

#### 값 삭제

```python
list.remove(x)
# 첫 번째로 나오는 x를 삭제_값으로 삭제
```

#### 인덱스로 삭제

```python
del list[index]
# index번째의 요소 삭제
del a[2:]
# 슬라이싱 기법을 이용해 삭제
```

#### 추가

```python
list.insert(a,b)
# a번째에 b요소를 추가
```

#### 마지막 요소 삭제 & 반환

```python
list.pop()
# 맨 마지막 요소를 삭제하고 리턴
```

#### 개수 세기

```python
list.count(a)
# a가 몇 번 나오는지 리턴
```

#### 리스트 확장

```python
list.extend([a,b]) # list += [a,b] 와 동일
# list에 다른 리스트를 추가
```






## 스택
빨래바구니에서 빨래를 꺼낼 때 가장 마지막에 넣은 빨래를 첫 번째로 꺼내는 것처럼 Last-In-First-Out(LIFO) 구조를 갖는다

위에서 설명했듯이 스택을 사용할때 리스트를 사용한다.

리스트 메서드에도 마지막 원소를 반환하는 `pop()`과, 리스트의 끝에 원소를 붙이는 `append()`, 마지막 원소를 조회하는 `list[-1]`를 사용하면 스택의 기능을 사용할 수 있다.

<img src="https://user-images.githubusercontent.com/17975647/169685258-ef273809-aa63-4855-ac69-07ab7cfba3f0.png" alt="stack" style="zoom:20%;" />

## 큐

놀이공원에서 놀이기구를 타기 위해 첫 번째로 대기한 사람이 가장 먼저 놀이기구를 타듯, First-In-First-Out(FIFO) 구조를 가진다.

큐를 사용하기 위해서는 파이썬의 collections.deque()를 활용한다.

왜냐하면 리스트를 사용하게 되면 첫 번째 원소를 꺼내고 모든 아이템들을 앞으로 당겨주는 데 O(N)의 시간복잡도가 생기기 때문이다.

왼쪽의 원소를 꺼낼 때 `popleft()` 를 사용하며, 원소를 넣어줄 때는 리스트와 동일하게 `append(x)`를 사용한다. 또한 첫 번째 원소를 조회하기 위해서는 `list[0]`을 사용한다.



<img src="https://user-images.githubusercontent.com/17975647/169685257-14d0705b-11a1-4b88-98e7-977ee9969e6e.png" alt="queue" style="zoom:20%;" />

## 해시테이블 

#### **해시 함수**

임의 크기 데이터를 고정 크기 값으로 매핑하는데 사용하는 함수

 성능이 좋은 해시 함수란?

- 충돌이 적은 해시 함수
- 쉽고 빠른 연산
- 해시 테이블에 고루 퍼져 있어야 한다

#### 로드 팩터 

테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈 것 - *공실률*

load factor = n/k

로드 팩터가 증가하면 해시 테이블 성능은 감소한다

#### 파이썬의 해싱 방법 - 오픈 어드레싱

해싱 값에 다른 값이 이미 할당되어 있을 때(충돌)

빈 공간을 찾기 위해 타겟으로 선형 탐사를 진행한다 



파이썬에서 해시테이블을 사용하기 위해서는 key-value 형태로 값을 저장할 수 있는 **Dictionary**를 사용한다.

아래는 Dictionary를 사용하기 위한 선언 방법과 함수이다



### 선언

```python
my_dict = {}

my_dict = dict()

dict_ex = {'a': 1, 'b': 2}

newdict = dict( alice = 5, bob = 20, tony= 15, suzy = 30)
```



### 데이터 추가

```python
my_dict = dic()

my_dict[key] = value
```



### 데이터 삭제

```python
del my_dict[key]
```





## 그래프

- 정점(V)과 간선(E)으로 이루어진 자료구조

- 트리와는 다른점은 사이클이 존재할 수 있고 간선의 방향이 단방향인 것도, 양방향인 것도 있다.

- 그래프들의 연결 관계는 아래와 같이 행렬로 정의할 수도, 리스트로 정의할 수도 있다.

  ![graph](https://user-images.githubusercontent.com/17975647/169689288-3134a8d9-b1c9-46d8-999a-773bea84131e.png)

그래프의 탐색 기법

| | BFS | DFS | Dijkstra | Floyd Washall |
| :---: | :---: | :---: | :---: | :---: |
| 탐색방식| 자신과 연결된주변 정점부터 탐색| 인접 정점을 택해 끝날때까지 탐색| 간선에 음의 가중치가 없는 그래프에서 한 정점에서 각 정점까지 최소 가주치를 갖는 루트 탐색(BFS + 최단경로) | 간선에 양, 음의 가중치가 있는 그래프에서 모든 정점에 대해 각 정점까지 최소 가중치를 갖는 루트 탐색(모든 정점 + 최단경로) |
| 강점| 깊이가 깊은 그래프| 넓이가 넓은 그래프| 최단경로 탐색| 모든 정점에서의 최단경로, 양.음의 가중치|
| 약점| 너비가 넒은 그래프| 깊이가 깊은 그래프| 한 정점에 대해서만, 음수 가중치 불가| 속도가 느림|
| 구현법| Queue| Stack| BFS + 최소 힙| 3중 for문|
| 시간복잡도 | 인접행렬 : O(V^2), 인접리스트:O(V+E) | 인접행렬 : O(V^2), 인접리스트:O(V+E) | O(V^2) / O(E+VlogV)                                          | O(V^3)                                                       |







## BFS

같은 깊이에서 모든 원소를 탐색하고 다음 깊이로 넘어가는 탐색 방법

BFS 구현은 위에서 사용한 **Queue**를 이용한다. 그래서 collections.deque()를 활용하게 됨!

![bfs](https://user-images.githubusercontent.com/17975647/169689149-2d427144-3d97-4287-8bbd-70ebe694a707.jpg)



## DFS

### **DFS : Depth First Search**

갈 수 있는 만큼 탐색하다가 갈 수 없게 되면 다시 탐색

![dfs](https://user-images.githubusercontent.com/17975647/169689151-bbe938e8-42e5-46e6-97e6-16d1c47728a3.jpg)

### DFS의 구현 방법

1. **재귀 함수**
2. **스택** - 순서가 바뀌게 된다

